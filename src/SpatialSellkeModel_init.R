#########################################################
#                                                        
# Spatial SIR transmission model with the Sellke construction
# The model simulates infections spread between immobile hosts (e.g. poultry, farms, plants) using the Sellke construction.                         
# The model assumes only removal of the detected hosts (i.e. no preventive removal)                                                        
#                  Author:  Elisa Beninc√°    -  adapted by Egil Fischer                           
#                  Creation date  https://doi.org/10.1371/journal.pcbi.1008009
#########################################################
# Load farm locations and sizes
load("configuration_points_200X200_whittle.Rdata")
#
spatial.input<- read_excel("./input/20230404_AI_AnimalLocations_SizeType_v02.xlsx", sheet = 2)

#set random vaccination status between 0 (fully susceptible -> pmajor = 0) and 1 (fully immune -> pmajor =1)
spatial.input$vacstat <- sapply(spatial.input$TYPE,function(x){ifelse(x == "LAYER",runif(1),0)})
#set the infectious period distribution 
Tdist = function(vacstat){
  shape = 14.5; rate = 1.2;
  if(vacstat<=0.9){shape = 14; rate = 1.2;}
  if(vacstat<=0.3){shape = 49; rate = 5.0;}
  if(vacstat<=0.02){shape = 192; rate = 23;}
  return(rgamma(1, shape= shape, rate = rate))
}

#scale coordinates to km
spatial.input$X <- spatial.input$X/1000
spatial.input$Y <- spatial.input$Y/1000
spatial.input$nr <- c(1:nrow(spatial.input))

#visualise 
plot(spatial.input$X,spatial.input$Y)
points(spatial.input$X[K],spatial.input$Y[K], col = "red",pch = 15)

# the matrices of Tinf and Qinit have been generated by the following code. 
numsim <-2000
totpoints <- nrow(spatial.input)
Q_init_matrix <- matrix(0,nrow=numsim,ncol=totpoints)
T_inf_matrix <- matrix(0,nrow=numsim,ncol=totpoints)
for (ii in 1:numsim){
 Q_init_matrix[ii,] <- rexp(totpoints, rate = 1)
 #infectious period is determined by the vaccination status
 T_inf_matrix[ii,] <- sapply(spatial.input$vacstat, Tdist)
 }

# Select one point pattern (x and y coordinates) out of the 25. The matrix has 50  columns, because there are x and y coordinates for each point
matrix_points <- spatial.input[,c("X","Y")] # I select one point pattern as example
totpoints <- nrow(matrix_points) # total number of points
colnames(matrix_points) <- c("xcoord","ycoord")
# Add a column for the index
Index_points <- c(1:totpoints)
# Calculate the matrix of distances between points
# Express the coordinates as complex numbers for fast calculation of the euclidean distance
Coord <-
  (complex(length.out=2,real=matrix_points$xcoord,imaginary=matrix_points$ycoord));
distancematrix <- as.matrix(abs(outer(Coord,Coord,"-")))

# Define the transmission kernel and calculate the hazard matrix
# Rescale the parameters h0 used in Boender et al. to account for the change in size and number of farms (see main text)
h0 <- 0.002*5360/totpoints;
alpha <- 2.1;
r0 <- 1.9;
h_kernel <- function(r){h0/(1 + (r/r0)^alpha)} ; # transmission kernel as a function of r
beta<-1;

# Create an hazard matrix evaluating for each host j the chance to be infected by host i as a function of distance
hazardmatrix <- as.matrix(apply(distancematrix,MARGIN=c(1,2),FUN=h_kernel));
#discount hazard by vaccination
hazardmatrix <- t(t(hazardmatrix)*spatial.input$vacstat)
diag(hazardmatrix) <- matrix(0,nrow=totpoints); # because the chance of infecting itself is 0




# Model the transmission event between hosts
# Define the function handling the events in the spatial transmission model
# Event function has four entries: event_time= time at which an event occurs, eventtype= type of event, statustype=status of host,id_= ID of host
# eventtype: 2=infection; 3=removal;
# statustype: 1= susceptible; 2= infectious; 3= culled;

event <- function(time_event,eventype,statustype,id_){
  if (eventype==2 & statustype==1){
    # calculate the CFI up to that moment
    # I let the CFI grow also for the infected hosts, because they are infected.
    #Of course, the already infected hosts will not be considered in the calculation of the next infection time, because they are already infected
    CFI <<- CFI+
      beta*apply(matrix(hazardmatrix[which(indexI==1),],nrow=length(which(indexI==1)),totpoints), MARGIN=2,FUN=sum)*(time_event-tt) # In the rows (i) the  infected, in the columns (j) the susceptibles
    # save the CFI in the matrix of CFI
    index_new_event <<- index_new_event + 1
    CFI_matrix[index_new_event,] <<- CFI
    timevector <<- rbind(timevector,time_event)
    # update the status vector and the indices vectors for S and for I
    Status[id_] <<- 2 # now Status= 2 (infected)
    indexI[id_] <<- 1 # infected
    indexS[id_] <<- 1 # not susceptible anymore
    # save the number of infected over time in a list
    infected_over_time <<-
      rbind(infected_over_time,c(time_event,length(indexI[indexI==1])))
    # calculate the slope of the force of infection from this moment onwards
    bb[which(indexS==0)] <<-
      beta*apply(matrix(hazardmatrix[which(indexI==1),which(indexS==0)],nrow=length(which(indexI==1)),ncol=length(which(indexS==0))), MARGIN=2,FUN=sum)
    # in the rows (i) the infected, in thecolumns (j) the susceptibles
    # calculate the next infection events
    t_infection[which(indexS==0)] <<- (Q_init[which(indexS==0)]-
                                         CFI[which(indexS==0)])/bb[which(indexS==0)]
    t_infection[which(indexS==1|indexS==3)] <<- 10000000 # I set a very high number which is not going to happen
    # update the list of points to infect
    next_infection_host <<- which.min(t_infection)
    next_infection_time <<- t_infection[which.min(t_infection)]
    #update the time
    tt <<- time_event
    #update the list of hosts to infect
    List_to_infect <<- rbind(List_to_infect,data.frame(Event_time =
                                                         tt+next_infection_time, Type_event = rep(2,length(next_infection_host)),
                                                       id_host = next_infection_host))
    List_to_infect <<- List_to_infect[order(List_to_infect[,1]),]
    #update the list of hosts to remove
    List_to_remove <<-
      rbind(List_to_remove,data.frame(Event_time=tt+T_inf[id_],Type_event=3,id_host=id_
      ))
    List_to_remove <<- List_to_remove[order(List_to_remove[,1]),]
    return(1)} else if (eventype==2 & statustype==2) {# already infected
      return(0)} else if (eventype==2 & statustype==3) {# if it has been culled t cannot be infected
        return(0)} else if (eventype==3 & statustype==1) {# it does not occur
          return(0)}else if (eventype==3 & statustype==2){
            # calculate the CFI up to that moment
            # I let the CFI grow also for the infected hosts, because they are  infected.
            # Of course they will not be considered in the calculation of the next infection time, because they are already infected
            CFI <<- CFI +
              beta*apply(matrix(hazardmatrix[which(indexI==1),],nrow=length(which(indexI==1)),totpoints),MARGIN=2,FUN=sum)*(time_event-tt)
            index_new_event <<- index_new_event + 1
            CFI_matrix[index_new_event,] <<- CFI
            # track the CFI over time
            timevector <<- rbind(timevector,time_event) # track the time
            # update the status vector and the indices vectors for S and for I
            Current[,3] <<- id_
            Status[id_] <<- 3 #culled
            indexI[id_] <<- 3 #culled, it will not contribute to the infectious matrix anymore
            indexS[id_] <<- 3 #culled, it is not susceptible anymore
            # save the number of infected over time in a list
            infected_over_time <<-
              rbind(infected_over_time,c(time_event,length(indexI[indexI==1])))
            if(length(which(indexI==1))!=0){ # if there are still individual    infected
              # update the slope of the force of infection
              bb[which(indexS==0)] <<-
                beta*apply(matrix(hazardmatrix[which(indexI==1),which(indexS==0)],nrow=length(which(indexI==1)), ncol=length(which(indexS==0))),MARGIN=2,FUN=sum)
              # calculate for each susceptible the next possible infection event
              t_infection[which(indexS==0)] <<- (Q_init[which(indexS==0)]-
                                                   CFI[which(indexS==0)])/bb[which(indexS==0)]
              t_infection[which(indexS==1|indexS==3)] <<- 10000000
              # update the time
              tt <<- time_event
              next_infection_host <<- which.min(t_infection)
              next_infection_time <<- t_infection[which.min(t_infection)]
              # if the next infection host is already in the queue, you need to remove the old one and add the new one with the updated time of infection
              if ((next_infection_host%in%List_to_infect$id_host)==TRUE){
                List_to_infect <<- List_to_infect[-
                                                    (which((List_to_infect$id_host%in%next_infection_host)==TRUE)),]
              }
              List_to_infect <<-
                rbind(List_to_infect,data.frame(Event_time=tt+next_infection_time,Type_event=rep(
                  2,length(next_infection_time)),id_host=next_infection_host))
              List_to_infect <<- List_to_infect[order(List_to_infect[,1]),]
            } else if (length(which(indexI==1)) == 0){# if there are no infection events anymore the cumulative force infection of the susceptible should be set to
              0
              #update the slope of the force of infection
              bb[which(indexS==0)] <<- 0
              List_to_infect <<- {}
            }
            return(1)}
}


# code of InitSim.R sourced in the main code
# initialize vector status with 1 (all susceptibles)
Status <- matrix(1,nrow=totpoints) # status is a vector recording the state of each host
colnames(Status) <- "status" #1= susceptible, 2=infectious, 3 culled
Queue <- {}
History <- {}
Current <- {}
infected_over_time <- {}
time_vector <- {} # Initialize the Cumulative Force of Infection at the  begininng of the epidemic
CFI <- matrix(0,nrow=totpoints)
CFI_matrix <- matrix(0,ncol=totpoints,nrow=10000)
index_new_event <- 0
counter <- 0
# create vectors for the infected and the susceptibles, to use to compute the  cumulative force of infection
# These are index used for the calculation of the cumulative force of infection.
# They are used to keep track which hosts are infected or susceptible.
List_to_remove <- {}
List_to_infect <- {}
indexI <- matrix(0,nrow=totpoints) #indexI==0, not yet infected, indexI==1 infected, indexI==3 culled
indexS <- matrix(0,nrow=totpoints) # indexS==0, not yet infected, indexS==1 infected, indexS=3 culled
t_infection <- matrix(0,nrow=totpoints)
# coefficient of increase
bb <- matrix(0,nrow=totpoints)
tt <- 0 # start at time 0
next_infection_time <- 0
next_infection_host <- 0
####### # initialize with the first one to be infected
firstone <- K
Status[firstone] <- 2 # now Status= 2 (infected)
indexI[firstone] <- 1 # infected
indexS[firstone] <- 1 # not susceptible anymore
#calculate coefficient of increase
bb[which(indexS==0)] <-
  beta*apply(matrix(hazardmatrix[which(indexI==1),which(indexS==0)],nrow=length(which(indexI==1)),ncol=length(which(indexS==0))), MARGIN=2,FUN=sum) # In the rows (i) the infected. in the j the supectibles
t_infection[which(indexS==0)] <- (Q_init[which(indexS==0)]-  CFI[which(indexS==0)])/bb[which(indexS==0)]
t_infection[which(indexS==1)] <- 10000000 # I set an extremely high number,because it cannot infect itself
next_infection_time <- min(t_infection)
next_infection_host <- which.min(t_infection) # add this infected host to the history vector
History <-rbind(History,data.frame(Event_time=tt,Type_event=2,host_id=firstone,x_coord=Re(Coord[as.numeric(firstone)]),y_coord=Im(Coord[as.numeric(firstone)]))) # record it in the history vector. In the history vector add the coord
# update the list_to_infect and the list_to remove
List_to_infect <- rbind(List_to_infect,data.frame(Event_time=tt
                                                  +next_infection_time,Type_event=2,id_host = next_infection_host))
List_to_infect <- List_to_infect[order(List_to_infect[,1]),]
List_to_remove <- rbind(List_to_remove,data.frame(Event_time=tt
                                                  +T_inf[firstone],Type_event=3,id_host=firstone))
List_to_remove <- List_to_remove[order(List_to_remove[,1]),]
next_events <- rbind(List_to_infect[1,],List_to_remove[1,])
index_next_event <- which.min(next_events[,1])
Queue <- rbind(Queue,next_events[index_next_event,])
# now remove this event from the list_to_infect or list_to_remove
if(all.equal(cbind(List_to_infect[1,1],List_to_infect[1,2],List_to_infect[1,3]),cbind(Queue[1,1],Queue[1,2],Queue[1,3]))==TRUE){
  List_to_infect <- List_to_infect[-c(1),]
} else
  if(all.equal(cbind(List_to_remove[1,1],List_to_remove[1,2],List_to_remove[1,3]),cbind(Queue[1,1],Queue[1,2],Queue[1,3]))==TRUE){
    List_to_remove <- List_to_remove[-c(1),]
  }
# I add the current CFI (which is 0 at the beginning of the CFI_matrix)
index_new_event <- index_new_event+1
CFI_matrix[index_new_event,] <- CFI
timevector <- rbind(time_vector,tt)
infected_over_time <- rbind(infected_over_time,c(0,length(indexI[indexI==1])))

